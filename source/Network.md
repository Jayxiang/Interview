# iOS 面试-网络相关

- [网络的几层协议](# 网络的几层协议)
- [GET 和 POST 区别](# GET 和 POST 区别)
- [UDP 和 TCP 的区别是什么？](# UDP 和 TCP 的区别是什么？)
- [Cookie 和 Session](# Cookie 和 Session)
- [TCP/IP 建立连接和断开连接的过程？](# TCP/IP 建立连接和断开连接的过程？)
- [为什么 TCP 连接建立需要三次握手](# 为什么 TCP 连接建立需要三次握手)
- [为什么建立连接是三次握手，而关闭连接却是四次挥手呢？](# 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？)
- [HTTPS 建立流程](# HTTPS 建立流程)

#### 网络的几层协议
```
1.应用层：FTP、HTTP，也可以加上表示层：TIFF、JPEG|MPEG 会话层：RPC、SQL
2.传输层：TCP、UDP
3.网络层：IP、IPX、ICMP；
4.数据链路层：802.2、802.3ATM
5.物理层：V.35、EIA/TIA-232
```

#### GET 和 POST 区别
```
参数携带方式不同：GET 是以？拼接的方式，POST 是在 body 中
参数长度限制：GET 一般限制 1024 字符，POST 一般没有限制
GET：获取资源，他是安全的，幂等的，可缓存的
POST：处理资源，他是非安全的，非幂等的，非可缓存的
安全性：不引起 server 端任何状态变化。如 GET、HEAD、OPTIONS
幂等性：同一个请求方法执行多次和执行一次的效果完全相同。如：GET、PUT、DELETE
可缓存行：请求是否可以缓存。如：GET、HEAD
```
#### UDP 和 TCP 的区别是什么？
```
TCP（传输控制协议）：面向连接：三次握手，四次挥手
传输可靠：通过停止等待协议，保证数据无差错、不丢失、不重复、按序到达
面向字节流
流量控制：滑动窗口协议，简单的说一下就是接收端在发送 ACK 的时候会带上缓冲区的窗口大小，
但是一般在窗口达到一定大小才会更新窗口
拥塞控制：慢开始，拥塞避免；快恢复，快重传

UDP（用户数据报协议）：无连接、传输不可靠、用于传输少量数据(数据包模式)、面向报文、速度快。
```
#### Cookie 和 Session
```
1、cookie 数据存放在客户的浏览器上，session 数据放在服务器上。

2、cookie 相比 session 不是很安全，别人可以分析存放在本地的 cookie 并进行 cookie 欺骗,
考虑到安全应当使用 session。

3、session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,
考虑到减轻服务器性能方面，应当使用 cookie。

4、单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存20个 cookie。
 而 session 存储在服务端，可以无限量存储

5、所以：将登录信息等重要信息存放为 session ;其他信息如果需要保留，可以放在 cookie 中
```
#### TCP/IP 建立连接和断开连接的过程？
```
- 在 TCP/IP 协议中，TCP 协议提供可靠的连接服务，采用三次握手建立连接；
- 第一次握手：建立连接时，客户端发送连接请求到服务器，并进入 SYN_SEND 状态，等待服务器确认；
- 第二次握手：服务器收到客户端连接请求，向客户端发送允许连接应答，
  此时服务器进入 SYN_RECV 状态；
- 第三次握手：客户端收到服务器的允许连接应答，向服务器发送确认，客户端和服务器进入通信状态，
  完成三次握手。
 （所谓的三次握手，就是要有三次连接信息的发送、接收过程。
   TCP 连的建立需要进行三次连接信息的发送、接收。）

当客户端和服务端的连接想要断开的时候，要经历四次挥手的过程，步骤如下：
1. 先由客户端向服务端发送 FIN 结束报文。
2. 服务端会返回给客户端 ACK 确认报文 。此时，由客户端发起的断开连接已经完成。
3. 服务端会发送给客户端 FIN 结束报文 和 ACK 确认报文。
4. 客户端会返回 ACK 确认报文到服务端，至此，由服务端方向的断开连接已经完成。

几个概念：URG：紧急指针（urgent pointer）有效。
ACK：确认序号有效。
PSH：接收方应该尽快将这个报文交给应用层。
RST：重置连接。
SYN：发起一个新连接。
FIN：释放一个连接。
```
![三次握手. jpg](./image/三次握手.jpg)
![四次挥手. jpg](./image/四次挥手.jpg)

#### 为什么 TCP 连接建立需要三次握手
```
“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。
如：“已失效的连接请求报文段”的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，
而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。
本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，
就误认为是 client 再次发出的一个新的连接请求。
于是就向 client 发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要 server 发出确认，
新的连接就建立了。
由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。
但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。
这样，server 的很多资源就白白浪费掉了。
采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。
server 由于收不到确认，就知道 client 并没有要求建立连接。
综合：只需要三次握手，可以提高连接的速度与效率。
```
#### 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？
```
这是因为服务端在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，
把 ACK 和 SYN 放在一个报文里发送给客户端。
而关闭连接时，当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，
我们也未必全部数据都发送给对方了，
所以我们不可以立即 close，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，
因此，我们的 ACK 和 FIN 一般都会分开发送。
```
#### HTTPS 建立流程
```
HTTPS 协议 = HTTP 协议 + SSL/TLS 协议
SSL 的全称是 Secure Sockets Layer，即安全套接层协议，
是为网络通信提供安全及数据完整性的一种安全协议。
TLS 的全称是 Transport Layer Security，即安全传输层协议。
即 HTTPS 是安全的 HTTP。
HTTPS 连接过程大致可分为八步:

1、客户端访问 HTTPS 连接。
客户端会把安全协议版本号、客户端支持的加密算法列表、随机数 C 发给服务端。

2、服务端发送证书给客户端
服务端接收密钥算法配件后，会和自己支持的加密算法列表进行比对，如果不符合，则断开连接。
否则，服务端会在该算法列表中，选择一种对称算法（如 AES）、一种公钥算法（如具有特定秘钥长度的 RSA）
和一种 MAC 算法发给客户端。
服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，
不能将其泄露，公钥可以发送给任何人。
在发送加密算法的同时还会把数字证书和随机数 S 发送给客户端

3、客户端验证 server 证书
会对 server 公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么 HTTPS 传输就无法继续。

4、客户端组装会话秘钥
如果公钥合格，那么客户端会用服务器公钥来生成一个预主秘钥(Pre-Master Secret，PMS)，
并通过该预主秘钥和随机数 C、S 来组装成会话秘钥

5、客户端将预主秘钥加密发送给服务端
是通过服务端的公钥来对预主秘钥进行非对称加密，发送给服务端

6、服务端通过私钥解密得到预主秘钥
服务端接收到加密信息后，用私钥解密得到主秘钥。

7、服务端组装会话秘钥
服务端通过预主秘钥和随机数 C、S 来组装会话秘钥。
至此，服务端和客户端都已经知道了用于此次会话的主秘钥。

8、数据传输
客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。
同理，服务端收到客户端发送来的密文，用服务端密钥对其进行对称解密，得到客户端发送的数据。

总结：
会话秘钥 = random S + random C + 预主秘钥

HTTPS 连接建立过程使用非对称加密，而非对称加密是很耗时的一种加密方式

后续通信过程使用对称加密，减少耗时所带来的性能损耗

其中，对称加密加密的是实际的数据，非对称加密加密的是对称加密所需要的客户端的密钥。
```
![HTTPS.png](./image/HTTPS.png)
